                Abstract Data Types:::              

Queue:
    - FIFO: first in first out
    - enqueue - to let into queue
    - dequeue - to let out of line

    const int capacity = 50;
    typedef struct
    {
        person people[capacity];
        int size; //number of items actually in queue currently
    } queue;


Stack:
    - LIFO: last in first out
    push: to push item on top of stack
    pop: to pop item on top of stack

Using . and * together = -> : to point to locations in memory
    //refer list.c
    #include <stdlib.h>
    int main()
    {
        int *list = malloc(3 * sizeof(int));
        if(list == NULL){
            return 1;
        }
        list[0] = 1;
        list[1] = 2;
        list[2] = 3;

        int *temp = malloc(4 * sizeof(int));
        if(temp == NULL){
            free(list); //super subtle but free successfully allocated memory before exiting program
            return 1;
        }
        for(int i = 0; i < 3; i++){
            temp[i] = list[i];
        }
        temp[3] = 4;
        
        free(list);
        list = tmp;

        for(int i = 0; i < 3; i++){
            printf("%d\n", list[i]);
        }

        free(list);
        return 0;
    }

    // this all work could be saved using linked list******


Linked Lists:
    - if we can link different chunks of data on different locations
    - so each location can point to another location
    
Memory and its location ->    [ 1 : 0x123]    [ 2: 0x234]     [ 3: 0x723]
Location its pointer points:  [   0x234  ]    [  0x723  ]     [   NULL  ]
While an extra pointer keeps track of start of list:

|  |--->| 1 |
        |   |---->| 2 |
                  |   |---->| 3 |
                            |   |
 = spending more space but more flexibility to link data than allocating more new memory



NODE:

typedef struct node
{
    int number;
    struct node *next;
}node;

=> Linked list cannot perform binary search since you cannot go back and forth

TREE:
: 2 dimensional data structure
eg: Binary search tree

bool search(node *tree, int number)
{
    if(tree == NULL)
    {
        return false;
    }
    else if(number <tree-> number)
    {
        return search(tree->left, number);
    }
    else if(number>tree->number)
    {
        return(tree->right, number);
    }
    else(number == tree->number)
    {
        return true;
    }
}


HASHING:
hash allows to decide where a value goes in the memory
Hash tables: like array and linked list together
stores key value pair

TRIES
data structure to retrieve data
is a tree of arrays